---
title: 그래프의 절단점과 절단선 찾기
date: 2019-11-05 21:11:92
category: algorithm
---

## 간선의 분류 

절단점과 절단선을 구분하기 위해 먼저 그래프에서 간선을 분류해보자. 

### 스패닝 트리 

그래프에서 한 정점을 깊이 우선 탐색했을 때, 탐색이 따라간 간선들만 모아서 보면 트리 형태를 띄는 것을 알 수 있다. 이를 `스패닝 트리` 라고 부른다. 



### 간선의 분류 

이렇게 스패닝 트리를 만들면 그래프의 모든 간선을 네 가지로 분류할 수 있다. 

1. Tree edge: 스패닝 트리에 포함된 간선 
2. forward edge: 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선은 아닌 간선 
3. back edge: 스패닝 트리의 자손에서 선조로 연결되는 간선 
4. cross edge: 위 세가지 분류에 속하지 않는 간선 

그렇다면 어떻게 분류할 수 있을까? 

1. Tree edge

   ```
   dfs(u)내에서 간선 (u, v)를 검사했을 때, v가 방문된 적이 없다면 (u, v)는 트리 간선이다. 
   ```

2. 나머지 edge

   ```
   dfs(u)내에서 간선 (u, v)를 검사했을 때, v가 이미 방문되었다면 v가 u의 부모인지, 자손인지, 둘 다 아닌지 알 수 없다. 
   따라서 방문 순서를 기록하도록 discovered를 구성해야 한다. 
   이때, 
   1) (u, v)가 forward edge라면 v는 u의 자손이어야 하므로, discovered[v] > discovered[u]
   2) (u, v)가 back edge라면 v는 u의 선조이므로, discovered[v] < discovered[u]
   3) (u, v)가 cross edge라면 dfs(v)가 종료한 후 dfs(u)가 호출되어야 하므로 discovered[v] < discovered[u] 
   
   근데 여기서 문제점은 back과 cross를 구별할 수 가 없다. 따라서 finished라는 배열을 추가로 두어 dfs(v)의 종료 여부를 기록하여 둘을 구분한다. 
   ```

#### code 

```cpp
vector<vector<int>> adj; 
vector<int> discovered, finished; 
int counter = 0;
void dfs(int here) {
  discovored[here] = counter++; 
  for(auto &there:adj[here]) {
    if(discovered[there] == -1) {
      cout << "tree edge" <<endl; 
      dfs(there);
    } else {
      if(discovered[here] < discovered[there])
        cout << "forward edge" << endl;
      else {
        if(!finished[there])
          cout << "back edge" << endl;
        else 
          cout << "cross edge" << endl;
      }
    }
  }
  finished[here] = true; 
}
```



## 절단점과 절단선 

> 여기서는 모든 그래프를 무방향 그래프라고 가정합니다. 
>
> 기억하세요! 무향그래프는 cross edge를 가지지 않습니다. 

### 절단점 

가장 간단하게 찾는 방법은 해당 정점을 그래프에서 삭제한 뒤 컴포넌트 개수가 이전보다 늘어났는지를 확인하는 것이다. 하지만 모든 정점에 대해 이 방법을 사용하면 dfs를 |V|번 수행하게 되어 성능이 매우 안좋다. 

위에 소개했던 간선의 분류를 통해 한 번의 dfs로 절단점을 찾을 수 있다. 어떻게? 

먼저, 

### 절단선 

> Bridge라고 부르며, 제거되었을 때 그래프의 컴포넌트 개수가 증가하게 되는 간선을 의미한다. 

DFS로 절단선을 찾을 수 있다. 어떻게! 

