---
title: 운영체제1
date: 2019-09-30 19:09:44
category: tech
---

> [참조1](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS), [참조2](https://mooneegee.blogspot.com/2015/01/os-thread.html)

## 프로세스와 스레드의 차이

### 프로세스 

프로세스는 실행 중인 프로그램이다. 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있다. 프로세스는 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받는다. 

![프로세스 메모리 구조에 대한 이미지 검색결과](https://wayhome25.github.io/assets/post-img/cs/virtual_address_space2.png)

- 스택: 지역변수가 저장되는 공간 
- 힙: 프로그래머의 동적 할당을 위해 존재하는 공간 
- 데이터: 전역변수, static 변수의 할당을 위해 존재하는 공간 
- code: 기계어

#### PCB (Process Control Block, PCB)

특정 프로세스에 대해 중요한 정보를 저장하고 있는 운영체제의 자료구조.

운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다. 

> 왜 PCB가 필요할까? 
>
> 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 중지하고 CPU를 반환해야 하는데, 이때 작업 진행 상황을 모두 PCB에 저장한다. 

*PCB에 저장되는 정보*

| 정보                  | 설명                                             |
| --------------------- | ------------------------------------------------ |
| 프로세스 식별자 (PID) | 프로세스 식별번호                                |
| 프로세스 상태         | 프로세스의 상태를 저장 (new, ready, running 등)  |
| 프로그램 카운터       | 프로세스가 다음에 실행할 명령어의 주소           |
| CPU 레지스터          |                                                  |
| CPU 스케줄링 정보     | 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등  |
| 메모리 관리 정보      | 페이지 테이블 또는 세그먼트 테이블               |
| 입출력 상태 정보      | 프로세스에 할당된 입출력 장치들과 열린 파일 목록 |

#### 프로세스 상태 변화 

![img](https://t1.daumcdn.net/cfile/tistory/99E85E3A5C460F1906)



### 스레드 

스레드는 프로세스의 실행 단위라고 할 수 있다. 스레드는 다음과 같이 구성된다. 

1. 스레드 ID
2. 레지스터 
3. 스택 

스레드는 data, heap 영역을 공유하기 때문에 IPC 없이도 스레드 간의 통신이 가능하다. 동일한 프로세스 내부에 존재하는 스레드 A, B가 통신하기 위해 head 영역에 메모리를 할당하고, 두 스레드가 자우롭게 접근할 수 있다. 

![img](https://2.bp.blogspot.com/-3AB4sE53Dfw/VMVNdWa_V0I/AAAAAAAAACo/UAGFO7f6_UA/s1600/euva3a00.p54z.gif)

> **스택을 스레드마다 독립적으로 할당하는 이유**
>
> : 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이다. 따라서 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당

> **PC 레지스터를 스레드마다 독립적으로 할당하는 이유**
>
> 프로그램 카운터(PC) 는 스레드가 명령어의 어디까지 수행했는지를 나타낸다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 시 선점당하기 때문에 명령어가 연속적으로 수행될 수 없다. 따라서 어디까지 수행했는지 기억해두어야한다. 

> **user-level thread vs. kernel level thread**
>
> User-level thread는 응용프로그램과 link/load 되는 라이브러리로 구현이 되고, 이 라이브러리에 동기화, 스케줄링 기능을 모두 가진다. 커널에서는 어떤 지원도 해주지 않으며 커널이 봤을 때 user-level thread는 single process이다. Linux에서는 `pthread` 라이브러리가 유저레벨에서 관리. 
>
> Kernel-level thread는 커널이 관리한다. 그래서 커널스레드는 유저스레드보다 생성과 관리 측면에 서 느리다. 
>
> **I/O 연산은 커널스레드에서**
>
> 

### 멀티 스레드의 장점 

프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현하면 메모리 공간과 시스템 자원 소모가 줄어든다. 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아닌 힙 영역을 이용하여 데이터를 주고 받을 수 있다. 스레드의 context switch는 프로세스의 context switch와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다. 

> 정리하자면 1.컨텍스트 스위치 비용이 감소한다. 2. 힙 영역 덕분에 자원을 효율적으로 사용한다. 

### 멀티 스레드의 문제점 

멀티 프로세스 기반에서는 프로세스 간 공유하는 자원이 없어서 동일한 자원에 동시에 접근하는 일이 없지만(힙을 얘기하는 건가?) 멀티 스레딩을 기반으로 할 때는 힙영역을 공유하기 때문에 동기화를 신경써야 한다. 

동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤해야 한다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 수 있기 때문에 과도한 락으로 인한 병목현상을 줄여야한다. 

> 멀티프로세스도 같은 자원에 접근할 때가 있잖아요 :grey_question: 
>
> 프로세스 간에 통신을 하려면 IPC(세마포어, 큐, 공유메모리)를 통해야 한다. 
>
> [참고](https://jungwoon.github.io/os/2019/07/31/Process-Synchronization/)

### 멀티 스레드 vs. 멀티 프로세스 

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 문제점과 동기화 문제가 있다. 

멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있다. 

따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하여 적용해야 한다. 

> 어떤 시스템의 특성에 따라 구분될 수 있을까? 
>
> 서로 관련된 기능을 한다면 멀티스레드로 구현하는 것이 좋다. 

[병렬프로그래밍](https://12bme.tistory.com/68)

