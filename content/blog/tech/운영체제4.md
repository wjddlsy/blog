---
title: 운영체제4
date: 2019-10-01 19:09:47
category: tech
---



## 메모리 관리 전략 

각각의 프로세스는 독립된 메모리 공간을 가지고 운영체제나 다른 프로세스의 메모리 공간에 접근할 수 없다. 운영체제만 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다. 

> swapping: 메모리 관리를 위해 사용되는 기법. CPU 할당 시간이 끝난 메모리를 보조 기억장치(하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다. 

*:star:단편화 (Fragementation)*

: 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 프로세스 사이에 너무 작아서 사용할 수 없는 공간들이 늘어나게 되는데 이를 단편화라고 부른다.

- 외부 단편화

  : 총 메모리 공간은 요구하는 공간을 만족하지만 연속되지 않는다.

- 내부 단편화

  : 요청의 크기가 메모리의 최소 할당 크기보다 작은 경우에 발생

### 외부 단편화 문제의 해결 

- 메모리 압축 (하드디스크 조각 모음과 유사)

  : 분산된 자유 공간을 모아서 큰 블록을 생성한다. 프로세스의 주소 공간이 동적으로 재배치 가능하여야 한다. 따라서 운영체제의 비용이 많이 드는 작업이기 때문에 효율적이지 못하다. 

- *페이징과 세그멘테이션*

  : 한 프로세스의 논리 주소 공간을 여러 개로 분할하여 비연속적인 물리 메모리 공간에 할당한다. 



### 페이징 

논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야 하는 제약을 해결한다. 스와핑 하는 경우에도 디스크에 연속적으로 저장될 필요가 없다. 

- 필요조건 

  1. 논리 주소 공간과 물리 주소 공간을 분리해야 하기 때문에 `주소의 동적 재배치`를 허용해야 한다.

  2. 전용 하드웨어 (MMU)

     논리 주소와 물리 주소의 변환을 위해 필요하다.  



**프레임**

: 물리 메모리의 고정 크기 블록 

**페이지**

: 논리 메모리의 고정 크기 블록 (프레임과 같은 크기)

![image-20191014200146075](images/image-20191014200146075.png)

#### 페이징 하드웨어 - MMU

![image-20191014200305051](images/image-20191014200305051.png)



페이징은 외부단편화는 해결하지만 내부 단편화가 생기게 된다. 내부단편화는 페이지 크기보다 작은 메모리를 요청하는 경우에 발생한다. 페이지 크기가 작으면 내부 단편화를 감소시킬 수 있지만 페이지 테이블의 크기가 증가하게 된다. 그래서 현재 운영체제에서는 보통 4KB로 페이지의 크기를 할당한다. 



**프레임 테이블**

운영체제가 관리하는 메모리 프레임의 사용 정보를 저장. 

**페이징과 문맥 교환**

페이지 테이블을 재설정하기 위해 문맥 교환 시간이 증가하게 된다. 

**공유 페이지**

비교적 간단하게 메모리 공유를 지원한다. 



#### 페이지테이블의 구현 

유의해야할 점은 페이지 테이블도 메모리에 저장한다는 것이다. 

![image-20191014203121245](images/image-20191014203121245.png)

TLB miss가 나면 TLB가 없을 때보다 성능이 안 좋다. 그래서 최대한 TLB hit가 많이 나도록 설계되어야 한다. 

#### TLB (Translation Look-aside Buffer)

TLB miss가 났을 때 교체를 어떻게 해야 나중에 hit가 날 확률이 높아질까? 

**Address-space Identifier (ASID)**

**Effective Memory-Accesss Time (EAT) **

$EAT = (m+\epsilon)\alpha +(2m+\epsilon)(1-\alpha), \epsilon=\text{TLB success time}, m=\text{Memory access time}, \alpha=\text{TLB hit ratio}$

TLB hit 면 물리메모리 접근 시간과 TLB 접근 시간이, 실패면 두 번의 메모리 접근과 TLB 접근 시간이 소요된다. 



#### 페이지 테이블의 구조 

실제 컴퓨터 시스템에서는 페이지 테이블의 크기가 매우 크기 때문에 페이지 테이블을 연속된 메모리 공간에 배치하기가 어렵다. 

그래서 크기가 큰 페이지 테이블을 처리하기 위한 방법이 존재한다. 

1. 계층적 페이징 

   페이지 테이블 자체를 다시 페이징 = 외부 페이지 테이블 

   ￼![image-20191014212153616](images/image-20191014212153616.png)

   위 그림은 2단계 페이징을 나타낸 것이다. 

   하지만 계층적 페이지 테이블의 한계가 존재한다. 페이지 단계가 늘어날 수록 비효율적이다. 이미 64비트 체제에서 쓰기 힘들다. 그래서 유효한 페이지들만 테이블에 포함하는 해싱을 사용하여 효율성을 높인다. 

2. 해시 페이지 테이블 (Hashed Page Table)

   논리 주소의 페이지 번호를 해시 값으로 사용한다. 

   ![image-20191014213117805](images/image-20191014213117805.png)

3. 역 페이지 테이블 (Inverted Page Table)

   물리 주소를 논리 주소로 바꿔주는 테이블. RAM의 프레임 번호를 인덱스로 하여 페이지 번호를 찾을 수 있다. 한 시스템에 한 개의 페이지 테이블만 존재하기 때문에 주소 공간을 이용하여 프로세스를 구분시켜야 한다. 

   :smile: 장점

   작은 메모리 공간이 필요하다 

   :disappointed: 단점 

   주소 변환 시간이 길어짐 (검색 비용 증가), 메모리 공유가 어렵다. 

   ![image-20191014213839347](images/image-20191014213839347.png)

### 세그멘테이션

사용자/프로그래머 관점의 메모리 관리 기법이다. 페이징과 다른 점은 고정된 크기로 분할하는 것이 아닌 논리적으로 ... 

세그먼트의 예시 

- 프로그램의 논리적 단위 

  : method, procedure, function, object, ...

- C 컴파일러 관점 

  : 코드, 전역 변수, 힙, 스택, 표준 C 라이브러리 



페이징의 목적과는 다르게 프로세스를 구분하려는 느낌? ... 다른 프로세스의 메모리에 접근할 수 없도록 

실제로는 페이징과 세그멘테이션을 섞어서 segmented paging을 사용한다. 

#### 세그먼트 테이블 

세그먼트가 사상되는 물리 메모리의 주소를 제공한다. 

![image-20191014214331896](images/image-20191014214331896.png)



## 가상 메모리 

프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하도록 하는 기법으로 프로그램이 물리 메모리보다 커도 된다는 장점이 있다. 





